// Generated by CoffeeScript 1.3.3
"use stict";

var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

(function(root, factory) {
  var dispatch, protocol, stream, tail, _base, _ref, _ref1;
  if ("object" === typeof exports) {
    protocol = require('./protocol');
    tail = require('./tail');
    dispatch = require('./dispatch');
    stream = require('./stream');
    module.exports = factory(protocol, tail, dispatch, stream);
  } else if (typeof define !== "undefined" && define !== null ? define.amd : void 0) {
    define(['./protocol', './tail', './dispatch', './stream'], factory);
  } else {
    if ((_ref = root.cosy) == null) {
      root.cosy = {};
    }
    if ((_ref1 = (_base = root.cosy).lang) == null) {
      _base.lang = {};
    }
    root.cosy.lang.sequence = factory(root.cosy.protocol, root.cosy.tail, root.cosy.dispatch(root.cosy.stream));
  }
})(this, function(protocol, tail, _arg, _arg1) {
  var ISeq, IStream, LazySeqence, Sequence, StreamSequence, concat, cons, drop, dropWhile, empty, filter, first, fn$, lazy, map, partition, reduce, rest, seq, sequence, take, takeWhile, vec;
  fn$ = _arg.fn$;
  IStream = _arg1.IStream;
  ISeq = protocol.define('ISeq', 'A logical list', ['first', 'Returns the first item in the collection. If coll is null, returns null'], ['rest', 'Returns a sequence of the items after the first. If there are no more items, returns a logical sequence for which seq returns null.']);
  protocol.extend(ISeq, null, [
    'first', function(coll) {
      return null;
    }
  ], [
    'rest', function(coll) {
      return null;
    }
  ]);
  protocol.extend(ISeq, Array, [
    'first', function(coll) {
      if (coll.length) {
        return coll[0];
      } else {
        return null;
      }
    }
  ], [
    'rest', function(coll) {
      return coll.slice(1);
    }
  ]);
  Sequence = (function() {

    function Sequence(head, tail) {
      this.head = head;
      this.tail = tail;
    }

    return Sequence;

  })();
  protocol.extend(ISeq, Sequence, [
    'first', function(coll) {
      return coll.head;
    }
  ], [
    'rest', function(coll) {
      return coll.tail;
    }
  ]);
  LazySeqence = (function(_super) {

    __extends(LazySeqence, _super);

    function LazySeqence(body) {
      if (typeof body !== 'function') {
        throw new Error('body must be a function');
      }
      this.realise = function() {
        var res;
        res = body();
        while (res instanceof LazySeqence) {
          res = res.realise();
        }
        this.realise = function() {
          return res;
        };
        return res;
      };
    }

    return LazySeqence;

  })(Sequence);
  StreamSequence = (function() {

    function StreamSequence(stream) {
      this.stream = stream;
    }

    return StreamSequence;

  })();
  protocol.extend(IStream, StreamSequence, [
    'tap', function(coll, fn) {
      return stream.tap(coll.stream, fn);
    }
  ], [
    'emit', function(coll, val) {
      return stream.emit(coll.stream, val);
    }
  ]);
  seq = function(coll) {
    if (!protocol["implements"](ISeq, coll)) {
      if (protocol["implements"](IStream, coll)) {
        coll = new StreamSequence(coll);
      } else {
        throw new Error('Does not implement ISeq');
      }
    }
    if (coll instanceof LazySeqence) {
      return coll.realise();
    }
    return coll;
  };
  cons = function(item, coll) {
    if (!protocol["implements"](ISeq, coll)) {
      throw new Error('Does not implement ISeq');
    }
    return new Sequence(item, coll);
  };
  first = function(coll) {
    return ISeq.first(seq(coll));
  };
  rest = function(coll) {
    seq(coll);
    return ISeq.rest(seq(coll));
  };
  lazy = function(body) {
    return new LazySeqence(body);
  };
  empty = function(colls) {
    var coll, _i, _len;
    for (_i = 0, _len = colls.length; _i < _len; _i++) {
      coll = colls[_i];
      if ((first(coll)) !== null) {
        return false;
      }
    }
    return true;
  };
  vec = function(coll) {
    var makeVec;
    makeVec = function(coll, A) {
      var item;
      if (A == null) {
        A = [];
      }
      item = first(coll);
      if (item === null) {
        return A;
      } else {
        A.push(item);
        return tail.recur(makeVec, rest(coll), A);
      }
    };
    return tail.loop(makeVec, coll);
  };
  map = function() {
    var colls, fn;
    fn = arguments[0], colls = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (empty(colls)) {
      return null;
    }
    return lazy(function() {
      var coll, firsts, rests, _i, _len;
      firsts = [];
      rests = [];
      for (_i = 0, _len = colls.length; _i < _len; _i++) {
        coll = colls[_i];
        firsts.push(first(coll));
        rests.push(rest(coll));
      }
      return cons(fn.apply(null, firsts), map.apply(null, [fn].concat(__slice.call(rests))));
    });
  };
  reduce = fn$({
    2: function(fn, coll) {
      var val;
      val = first(coll);
      if (val === null) {
        return fn();
      }
      return reduce(fn, val, rest(coll));
    },
    3: function(fn, val, coll) {
      var doReduce;
      doReduce = function(fn, val, coll) {
        var nextVal;
        if (empty([coll])) {
          return val;
        } else {
          nextVal = fn(val, first(coll));
          return tail.recur(doReduce, fn, nextVal, rest(coll));
        }
      };
      return tail.loop(doReduce, fn, val, coll);
    }
  });
  filter = function(pred, coll) {
    if (empty([coll])) {
      return null;
    }
    return lazy(function() {
      var f, r;
      f = first(coll);
      r = rest(coll);
      if (pred(f)) {
        return cons(f, filter(pred, r));
      } else {
        return filter(pred, r);
      }
    });
  };
  take = function(n, coll) {
    return lazy(function() {
      if (!n) {
        return null;
      }
      if (empty([coll])) {
        return null;
      }
      return cons(first(coll), take(n - 1, rest(coll)));
    });
  };
  takeWhile = function(pred, coll) {
    return lazy(function() {
      if (empty([coll])) {
        return null;
      }
      if (!pred(first(coll))) {
        return null;
      }
      return cons(first(coll), takeWhile(pred, rest(coll)));
    });
  };
  drop = function(n, coll) {
    return lazy(function() {
      if (!n) {
        return coll;
      }
      if (empty([coll])) {
        return null;
      }
      return drop(n - 1, rest(coll));
    });
  };
  dropWhile = function(pred, coll) {
    return lazy(function() {
      if (empty([coll])) {
        return null;
      }
      if (!pred(first(coll))) {
        return coll;
      }
      return dropWhile(pred, rest(coll));
    });
  };
  partition = fn$({
    2: function(n, coll) {
      return partition(n, n, coll);
    },
    3: function(n, step, coll) {
      return lazy(function() {
        if (empty([coll])) {
          return null;
        }
        return cons(take(n, coll), partition(n, step, drop(step, coll)));
      });
    }
  });
  concat = fn$({
    0: function() {
      return lazy(function() {
        return null;
      });
    },
    1: function(x) {
      return lazy(function() {
        return x;
      });
    },
    2: function(x, y) {
      return lazy(function() {
        if (empty([x])) {
          return y;
        } else {
          return cons(first(x), concat(rest(x), y));
        }
      });
    },
    $: function() {
      var x, y, z;
      x = arguments[0], y = arguments[1], z = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return concat.apply(null, [concat(x, y)].concat(__slice.call(z)));
    }
  });
  return sequence = {
    ISeq: ISeq,
    first: first,
    rest: rest,
    cons: cons,
    lazy: lazy,
    vec: vec,
    map: map,
    reduce: reduce,
    filter: filter,
    take: take,
    takeWhile: takeWhile,
    drop: drop,
    dropWhile: dropWhile,
    partition: partition,
    concat: concat
  };
});
