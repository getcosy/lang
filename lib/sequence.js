// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

(function(root, factory) {
  var ISeq, IStream, ISync, dispatch, promise, protocol, sink, tail, _base, _ref, _ref1;
  if ("object" === typeof exports) {
    protocol = require('./protocol');
    tail = require('./tail');
    dispatch = require('./dispatch');
    ISeq = require('./protocols/ISeq');
    ISync = require('./protocols/ISync');
    IStream = require('./protocols/IStream');
    sink = require('./stream/sink');
    promise = require('./promise');
    module.exports = factory(protocol, tail, dispatch, ISeq, ISync, IStream, sink, promise);
  } else if (typeof define !== "undefined" && define !== null ? define.amd : void 0) {
    define(['./protocol', './tail', './dispatch', './protocols/ISeq', './protocols/ISync', './protocols/IStream', './stream/sink', './promise'], factory);
  } else {
    if ((_ref = root.cosy) == null) {
      root.cosy = {};
    }
    if ((_ref1 = (_base = root.cosy).lang) == null) {
      _base.lang = {};
    }
    root.cosy.lang.sequence = factory(root.cosy.protocol, root.cosy.tail, root.cosy.dispatch, root.cosy.protocols.ISeq, root.cosy.protocols.ISync, root.cosy.protocols.IStream, root.cosy.stream.sink, root.cosy.lang.promise);
  }
})(this, function(protocol, tail, _arg, ISeq, ISync, IStream, sink, promise) {
  var IPromise, LazySeqence, Promise, Sequence, SyncedLazySequence, concat, cons, drop, dropWhile, empty, filter, first, fn$, lazy, map, partition, reduce, rest, seq, sequence, skip, take, takeWhile, vec;
  fn$ = _arg.fn$;
  "use strict";

  skip = IStream.skip;
  IPromise = promise.IPromise, Promise = promise.Promise;
  protocol.extend(ISeq, null, [
    'first', function(coll) {
      return null;
    }
  ], [
    'rest', function(coll) {
      return null;
    }
  ]);
  protocol.extend(ISeq, Array, [
    'first', function(coll) {
      if (coll.length) {
        return coll[0];
      } else {
        return null;
      }
    }
  ], [
    'rest', function(coll) {
      return coll.slice(1);
    }
  ]);
  Sequence = (function() {

    function Sequence(head, tail) {
      this.head = head;
      this.tail = tail;
    }

    return Sequence;

  })();
  protocol.extend(ISeq, Sequence, [
    'first', function(coll) {
      return coll.head;
    }
  ], [
    'rest', function(coll) {
      return coll.tail;
    }
  ]);
  LazySeqence = (function(_super) {

    __extends(LazySeqence, _super);

    function LazySeqence(body, coll) {
      if (typeof body !== 'function') {
        throw new Error('body must be a function');
      }
      this.realised = false;
      this.realise = function() {
        var res;
        if ((coll != null) && (first(coll)) === skip) {
          if (coll != null ? coll.isSink : void 0) {
            return cons(skip, this);
          }
          coll = rest(coll);
        }
        res = body(coll);
        while (res instanceof LazySeqence) {
          res = res.realise();
        }
        if ((first(res)) !== skip) {
          this.realised = true;
          this.realise = function() {
            return res;
          };
        }
        return res;
      };
    }

    return LazySeqence;

  })(Sequence);
  SyncedLazySequence = (function(_super) {

    __extends(SyncedLazySequence, _super);

    function SyncedLazySequence(body, coll) {
      var ready,
        _this = this;
      SyncedLazySequence.__super__.constructor.call(this, body, coll);
      ready = new Promise;
      ISync.onReady(coll, function() {
        _this.realise();
        if (_this.realised) {
          return IPromise.deliver(ready);
        }
      });
      this.onReady = function(fn) {
        return IPromise.when(ready, fn);
      };
    }

    return SyncedLazySequence;

  })(LazySeqence);
  protocol.extend(ISync, SyncedLazySequence, [
    'ready', function(s) {
      return s.realised;
    }
  ], [
    'onReady', function(s, fn) {
      return s.onReady(fn);
    }
  ]);
  seq = function(coll) {
    if (!protocol["implements"](ISeq, coll)) {
      if (protocol["implements"](IStream, coll)) {
        coll = sink(coll);
      } else {
        throw new Error('Does not implement ISeq');
      }
    }
    if (coll instanceof LazySeqence) {
      return coll.realise();
    }
    return coll;
  };
  cons = function(item, coll) {
    if (!protocol["implements"](ISeq, coll)) {
      throw new Error('Does not implement ISeq');
    }
    return new Sequence(item, coll);
  };
  first = function(coll) {
    return ISeq.first(seq(coll));
  };
  rest = function(coll) {
    seq(coll);
    return ISeq.rest(seq(coll));
  };
  lazy = fn$({
    1: function(body) {
      return new LazySeqence(body);
    },
    2: function(coll, body) {
      coll = seq(coll);
      if (protocol["implements"](ISync, coll)) {
        return new SyncedLazySequence(body, coll);
      } else {
        return new LazySeqence(body, coll);
      }
    }
  });
  empty = function(colls) {
    var coll, _i, _len;
    for (_i = 0, _len = colls.length; _i < _len; _i++) {
      coll = colls[_i];
      if ((first(coll)) !== null) {
        return false;
      }
    }
    return true;
  };
  vec = function(coll) {
    var makeVec;
    if (coll != null ? coll.isSink : void 0) {
      throw new Error('Cannot vec a sink');
    }
    makeVec = function(coll, A) {
      var item;
      if (A == null) {
        A = [];
      }
      item = first(coll);
      if (item === null) {
        return A;
      } else {
        A.push(item);
        return tail.recur(makeVec, rest(coll), A);
      }
    };
    return tail.loop(makeVec, coll);
  };
  map = fn$({
    0: function(fn, coll) {
      if (empty(colls)) {
        return null;
      }
      return lazy(coll, function(coll) {
        return cons(fn(first(coll)), map(fn, rest(coll)));
      });
    },
    $: function() {
      var colls, fn;
      fn = arguments[0], colls = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (empty(colls)) {
        return null;
      }
      return lazy(function() {
        var coll, firsts, rests, _i, _len;
        firsts = [];
        rests = [];
        for (_i = 0, _len = colls.length; _i < _len; _i++) {
          coll = colls[_i];
          if (coll != null ? coll.isSink : void 0) {
            throw new Error('Cannot multi map a sink');
          }
          firsts.push(first(coll));
          rests.push(rest(coll));
        }
        return cons(fn.apply(null, firsts), map.apply(null, [fn].concat(__slice.call(rests))));
      });
    }
  });
  reduce = fn$({
    2: function(fn, coll) {
      var val;
      val = first(coll);
      if (val === null) {
        return fn();
      }
      return reduce(fn, val, rest(coll));
    },
    3: function(fn, val, coll) {
      var doReduce;
      if (coll != null ? coll.isSink : void 0) {
        throw new Error('Cannot reduce a sink');
      }
      doReduce = function(fn, val, coll) {
        var nextVal;
        if (empty([coll])) {
          return val;
        } else {
          nextVal = fn(val, first(coll));
          return tail.recur(doReduce, fn, nextVal, rest(coll));
        }
      };
      return tail.loop(doReduce, fn, val, coll);
    }
  });
  filter = function(pred, coll) {
    if (empty([coll])) {
      return null;
    }
    return lazy(coll, function(coll) {
      var f, r;
      f = first(coll);
      r = rest(coll);
      if (pred(f)) {
        return cons(f, filter(pred, r));
      } else {
        return filter(pred, r);
      }
    });
  };
  take = function(n, coll) {
    if (!n) {
      return null;
    }
    if (empty([coll])) {
      return null;
    }
    return lazy(coll, function(coll) {
      return cons(first(coll), take(n - 1, rest(coll)));
    });
  };
  takeWhile = function(pred, coll) {
    if (empty([coll])) {
      return null;
    }
    if (!pred(first(coll))) {
      return null;
    }
    return lazy(coll, function(coll) {
      return cons(first(coll), takeWhile(pred, rest(coll)));
    });
  };
  drop = function(n, coll) {
    if (!n) {
      return coll;
    }
    if (empty([coll])) {
      return null;
    }
    return lazy(coll, function(coll) {
      return drop(n - 1, rest(coll));
    });
  };
  dropWhile = function(pred, coll) {
    if (empty([coll])) {
      return null;
    }
    if (!pred(first(coll))) {
      return coll;
    }
    return lazy(coll, function(coll) {
      return dropWhile(pred, rest(coll));
    });
  };
  partition = fn$({
    2: function(n, coll) {
      return partition(n, n, coll);
    },
    3: function(n, step, coll) {
      if (empty([coll])) {
        return null;
      }
      return lazy(coll, function(coll) {
        return cons(take(n, coll), partition(n, step, drop(step, coll)));
      });
    }
  });
  concat = fn$({
    0: function() {
      return lazy(function() {
        return null;
      });
    },
    1: function(x) {
      return x;
    },
    2: function(x, y) {
      return lazy(x, function(x) {
        if (empty([x])) {
          return y;
        } else {
          return cons(first(x), concat(rest(x), y));
        }
      });
    },
    $: function() {
      var x, y, z;
      x = arguments[0], y = arguments[1], z = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return concat.apply(null, [concat(x, y)].concat(__slice.call(z)));
    }
  });
  return sequence = {
    ISeq: ISeq,
    first: first,
    rest: rest,
    cons: cons,
    lazy: lazy,
    vec: vec,
    map: map,
    reduce: reduce,
    filter: filter,
    take: take,
    takeWhile: takeWhile,
    drop: drop,
    dropWhile: dropWhile,
    partition: partition,
    concat: concat
  };
});
