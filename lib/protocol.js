// Generated by CoffeeScript 1.4.0
var __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

(function(root, factory) {
  var identity, meta, _base, _ref, _ref1;
  if ("object" === typeof exports) {
    meta = require('./meta');
    identity = require('./identity');
    module.exports = factory(meta, identity);
  } else if (typeof define !== "undefined" && define !== null ? define.amd : void 0) {
    define(['./meta', './identity'], factory);
  } else {
    if ((_ref = root.cosy) == null) {
      root.cosy = {};
    }
    if ((_ref1 = (_base = root.cosy).lang) == null) {
      _base.lang = {};
    }
    root.cosy.lang.protocol = factory(root.cosy.lang.meta, root.cosy.lang.identity);
  }
})(this, function(_meta, identity) {
  "use strict";

  var Protocol, createDispatcher, defineMethod, extendMethod, getDispatchMap, getId, meta, methodDoc, protoDefine, protoDoc, protoExtend, protoExtends, protoImplements, protoType, protocol, types;
  protocol = {};
  meta = function(obj) {
    return _meta.ns(obj, 'protocol');
  };
  createDispatcher = function(name, doc, opts) {
    var fn, md;
    fn = function() {
      var any, args, method, type;
      any = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      type = any;
      if (!(any instanceof Object)) {
        type = new (protoType(any));
      }
      method = getDispatchMap(fn, type);
      if (method) {
        return method.apply(null, [any].concat(__slice.call(args)));
      } else {
        throw new Error('method not implemented');
      }
    };
    md = meta(fn);
    md.name = name;
    md.doc = doc;
    md.extendable = true;
    return fn;
  };
  defineMethod = function() {
    var doc, name, opts, proto;
    proto = arguments[0], name = arguments[1], opts = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    doc = null;
    if ('string' === typeof opts[opts.length - 1]) {
      doc = opts.pop();
    }
    return proto[name] = createDispatcher(name, doc, opts);
  };
  Protocol = (function() {

    function Protocol(name, doc, defs) {
      var def, md, _i, _len;
      md = meta(this);
      md.name = name;
      md.doc = doc;
      for (_i = 0, _len = defs.length; _i < _len; _i++) {
        def = defs[_i];
        defineMethod.apply(null, [this].concat(__slice.call(def)));
      }
    }

    return Protocol;

  })();
  protoDefine = function() {
    var defs, doc, name;
    name = arguments[0], defs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    doc = null;
    if ('string' === typeof defs[0]) {
      doc = defs.shift();
    }
    return new Protocol(name, doc, defs);
  };
  types = {};
  protoType = function(any) {
    var typeName, _ref;
    typeName = any === null ? 'null' : typeof any;
    if ((_ref = types[typeName]) == null) {
      types[typeName] = function() {};
    }
    return types[typeName];
  };
  getId = function(dispatcher) {
    return '$__cosy_protocols' + (identity.get(dispatcher));
  };
  getDispatchMap = function(dispatcher, any) {
    return any != null ? any[getId(dispatcher)] : void 0;
  };
  extendMethod = function(proto, type, name, fn) {
    var md;
    if (proto[name] == null) {
      throw new Error(name + ' not in interface');
    }
    md = meta(proto[name]);
    if (!md.extendable) {
      throw new Error(name + ' not extendable');
    }
    return type.prototype[getId(proto[name])] = fn;
  };
  protoExtend = function() {
    var method, methods, proto, type, _i, _len, _results;
    proto = arguments[0], type = arguments[1], methods = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    if (!(type instanceof Object)) {
      return protoExtend.apply(null, [proto, protoType(type)].concat(__slice.call(methods)));
    }
    type.prototype[getId(proto)] = true;
    _results = [];
    for (_i = 0, _len = methods.length; _i < _len; _i++) {
      method = methods[_i];
      _results.push(extendMethod.apply(null, [proto, type].concat(__slice.call(method))));
    }
    return _results;
  };
  protoExtends = function(proto, type) {
    if (!(type instanceof Object)) {
      return protoExtends(proto, protoType(type));
    }
    return type.prototype[getId(proto)] != null;
  };
  protoImplements = function(proto, any) {
    var type;
    type = any;
    if (!(any instanceof Object)) {
      type = new (protoType(any));
    }
    return type[getId(proto)] != null;
  };
  methodDoc = function(method) {
    var doc, md;
    md = meta(method);
    doc = {
      name: md.name,
      description: md.doc
    };
    return doc;
  };
  protoDoc = function(proto) {
    var doc, md, method;
    md = meta(proto);
    doc = {
      name: md.name,
      description: md.doc,
      methods: []
    };
    for (method in proto) {
      if (!__hasProp.call(proto, method)) continue;
      doc.methods.push(methodDoc(proto[method]));
    }
    return doc;
  };
  return protocol = {
    define: protoDefine,
    extend: protoExtend,
    "extends": protoExtends,
    "implements": protoImplements,
    doc: protoDoc
  };
});
