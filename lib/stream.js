// Generated by CoffeeScript 1.4.0

(function(root, factory) {
  var IStream, ISync, protocol, sequence, sink, _base, _ref, _ref1;
  if ("object" === typeof exports) {
    protocol = require('./protocol');
    IStream = require('./protocols/IStream');
    sequence = require('./sequence');
    ISync = require('./protocols/ISync');
    sink = require('./stream/sink');
    module.exports = factory(protocol, IStream, sequence, ISync, sink);
  } else if (typeof define !== "undefined" && define !== null ? define.amd : void 0) {
    define(['./protocol', './protocols/IStream', './sequence', './protocols/ISync', './stream/sink'], factory);
  } else {
    if ((_ref = root.cosy) == null) {
      root.cosy = {};
    }
    if ((_ref1 = (_base = root.cosy).lang) == null) {
      _base.lang = {};
    }
    root.cosy.lang.stream = factory(root.cosy.lang.protocol, root.cosy.lang.protocols.IStream, root.cosy.lang.sequence, root.cosy.lang.protocols.ISync, root.cosy.lang.stream.sink);
  }
})(this, function(protocol, IStream, sequence, ISync, sink) {
  "use strict";

  var Source, emit, pipe, skip, source, stream, tap;
  skip = IStream.skip;
  Source = (function() {

    function Source(seq) {
      var emit, emitAll, emitSync, init, initialised,
        _this = this;
      this.fns = [];
      initialised = false;
      init = function() {
        initialised = true;
        if (protocol["implements"](ISync, seq)) {
          return ISync.onReady(seq, emitSync);
        } else {
          return emitAll();
        }
      };
      emitSync = function() {
        var value;
        value = sequence.first(seq);
        if (value !== skip) {
          emit(value);
        }
        seq = sequence.rest(seq);
        return ISync.onReady(seq, emitSync);
      };
      emitAll = function() {
        var f, _results;
        _results = [];
        while (f = sequence.first(seq)) {
          if (f !== skip) {
            emit(f);
            _results.push(seq = sequence.rest(seq));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      emit = function(val) {
        var fn, _i, _len, _ref, _results;
        _ref = _this.fns;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn(val));
        }
        return _results;
      };
      this.tap = function(fn) {
        _this.fns.push(fn);
        if (!initialised) {
          return init();
        }
      };
    }

    return Source;

  })();
  protocol.extend(IStream, Source, [
    'tap', function(s, fn) {
      return s.tap(fn);
    }
  ], [
    'emit', function(s, val) {
      throw new Error('Cannot emit to a source');
    }
  ]);
  source = function(seq) {
    if (protocol["implements"](IStream, seq)) {
      return seq;
    }
    if (!protocol["implements"](sequence.ISeq, seq)) {
      throw new Error('Not a sequence');
    }
    return new Source(seq);
  };
  tap = function(s, fn) {
    s = source(s);
    return IStream.tap(s, fn);
  };
  emit = function(s, val) {
    return IStream.emit(s, val);
  };
  pipe = function(src, tgt) {
    src = source(src);
    return src.tap(function(val) {
      return emit(tgt, val);
    });
  };
  return stream = {
    IStream: IStream,
    sink: sink,
    source: source,
    skip: skip,
    tap: tap,
    emit: emit,
    pipe: pipe
  };
});
